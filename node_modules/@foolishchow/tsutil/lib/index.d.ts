import * as ts from "typescript";
export { $ } from './tsquery';
export { tsquery } from "@phenomnomnominal/tsquery";
export declare type createImportSpecifierOption = {
    propertyName?: ts.Identifier;
    name: ts.Identifier;
};
export declare const createImportSpecifier: (option: createImportSpecifierOption) => ts.ImportSpecifier;
export declare type ImportClauseOption = {
    name?: ts.Identifier;
    namedBindings?: ts.NamedImportBindings;
};
export declare const createImportClause: (option: ImportClauseOption) => ts.ImportClause;
declare type ImportDeclarationOption = {
    decorators?: ReadonlyArray<ts.Decorator>;
    modifiers?: ReadonlyArray<ts.Modifier>;
    importClause?: ts.ImportClause;
    moduleSpecifier: ts.Expression;
};
export declare const createImportDeclaration: (option: ImportDeclarationOption) => ts.ImportDeclaration;
declare type ArrowFunctionOption = {
    modifiers?: ReadonlyArray<ts.Modifier>;
    typeParameters?: ReadonlyArray<ts.TypeParameterDeclaration>;
    parameters: ReadonlyArray<ts.ParameterDeclaration>;
    type?: ts.TypeNode;
    equalsGreaterThanToken?: ts.EqualsGreaterThanToken;
    body: ts.ConciseBody;
};
export declare const createArrowFunction: (option: ArrowFunctionOption) => ts.ArrowFunction;
export declare const createTypeReferenceNode: (typeName: string | ts.Identifier | ts.QualifiedName, typeArguments?: ts.TypeNode[] | undefined) => ts.TypeReferenceNode;
declare type VariableDeclarationOption = {
    name: string | ts.BindingName;
    type?: ts.TypeNode;
    initializer?: ts.Expression;
};
export declare const createVariableDeclaration: (option: VariableDeclarationOption) => ts.VariableDeclaration;
declare type VariableStatementOption = {
    modifiers?: ReadonlyArray<ts.Modifier>;
    declarationList: ts.VariableDeclarationList | ReadonlyArray<ts.VariableDeclaration>;
};
export declare const createVariableStatement: (option: VariableStatementOption) => ts.VariableStatement;
declare type ParameterOption = {
    decorators?: ReadonlyArray<ts.Decorator>;
    modifiers?: ReadonlyArray<ts.Modifier>;
    dotDotDotToken?: ts.DotDotDotToken;
    name: string | ts.BindingName;
    questionToken?: ts.QuestionToken;
    type?: ts.TypeNode;
    initializer?: ts.Expression;
};
export declare const createParameter: (option: ParameterOption) => ts.ParameterDeclaration;
declare type MethodOption = {
    decorators?: ReadonlyArray<ts.Decorator>;
    modifiers?: ReadonlyArray<ts.Modifier>;
    asteriskToken?: ts.AsteriskToken;
    name: string | ts.PropertyName;
    questionToken?: ts.QuestionToken;
    typeParameters?: ReadonlyArray<ts.TypeParameterDeclaration>;
    parameters: ReadonlyArray<ts.ParameterDeclaration>;
    type?: ts.TypeNode;
    body?: ts.Block;
};
export declare const createMethod: (options: MethodOption) => ts.MethodDeclaration;
declare type InterfaceOption = {
    decorators?: ReadonlyArray<ts.Decorator>;
    modifiers?: ReadonlyArray<ts.Modifier>;
    name: string | ts.Identifier;
    typeParameters?: ReadonlyArray<ts.TypeParameterDeclaration>;
    heritageClauses?: ReadonlyArray<ts.HeritageClause>;
    members: ReadonlyArray<ts.TypeElement>;
};
export declare const createInterface: (options: InterfaceOption) => ts.InterfaceDeclaration;
declare type ModuleOption = {
    decorators?: ReadonlyArray<ts.Decorator>;
    modifiers?: ReadonlyArray<ts.Modifier>;
    name: ts.ModuleName;
    body?: ts.ModuleBody;
    flags?: ts.NodeFlags;
};
export declare const createModule: (option: ModuleOption) => ts.ModuleDeclaration;
declare type PropertyOption = {
    decorators?: ReadonlyArray<ts.Decorator>;
    modifiers?: ReadonlyArray<ts.Modifier>;
    name: string | ts.PropertyName;
    questionOrExclamationToken?: ts.QuestionToken | ts.ExclamationToken;
    type?: ts.TypeNode;
    initializer?: ts.Expression;
};
export declare const createProperty: (option: PropertyOption) => ts.PropertyDeclaration;
declare type PropertySignature = {
    modifiers?: ReadonlyArray<ts.Modifier>;
    name: ts.PropertyName | string;
    questionToken?: ts.QuestionToken;
    type?: ts.TypeNode;
    initializer?: ts.Expression;
};
export declare const createPropertySignature: (options: PropertySignature) => ts.PropertySignature;
declare type CallSignatureOption = {
    typeParameters?: ReadonlyArray<ts.TypeParameterDeclaration>;
    parameters: ReadonlyArray<ts.ParameterDeclaration>;
    type?: ts.TypeNode;
};
export declare const createCallSignature: (options: CallSignatureOption) => ts.CallSignatureDeclaration;
declare type FunctionDeclarationOption = {
    decorators?: ReadonlyArray<ts.Decorator>;
    modifiers?: ReadonlyArray<ts.Modifier>;
    asteriskToken?: ts.AsteriskToken;
    name?: string | ts.Identifier;
    typeParameters?: ReadonlyArray<ts.TypeParameterDeclaration>;
    parameters: ReadonlyArray<ts.ParameterDeclaration>;
    type?: ts.TypeNode;
    body?: ts.Block;
};
export declare const createFunctionDeclaration: (option: FunctionDeclarationOption) => ts.FunctionDeclaration;
declare type TypeAliasDeclarationOption = {
    decorators?: ReadonlyArray<ts.Decorator>;
    modifiers?: ReadonlyArray<ts.Modifier>;
    name: string | ts.Identifier;
    typeParameters?: ReadonlyArray<ts.TypeParameterDeclaration>;
    type: ts.TypeNode;
};
/**
 * ```
 *  modifiers(export)  decorators(@N)  type name<typeParameters> = type
 *   export          @N       type  name<T> =  {}
 *```
 */
export declare const createTypeAliasDeclaration: (option: TypeAliasDeclarationOption) => ts.TypeAliasDeclaration;
export declare const addComment: <T extends ts.Node>(node: T, comment: string | undefined, isFull?: boolean) => T;
export declare const addComments: <T extends ts.Node>(node: T, comment: string[], isFull?: boolean) => void;
export declare const parseComment: <T extends ts.Node>(node: T) => string[];
