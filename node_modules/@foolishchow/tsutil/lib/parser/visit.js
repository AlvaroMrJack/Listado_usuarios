"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = __importStar(require("typescript"));
function transformNode(originName, newName, node) {
    var t = function (context) { return function (node) {
        function Visit(node) {
            if (ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) && node.typeName.text == originName) {
                node = ts.updateTypeReferenceNode(node, ts.createIdentifier(newName), node.typeArguments);
            }
            if (ts.isQualifiedName(node) && ts.isIdentifier(node.left) && node.left.text == originName) {
                node = ts.updateQualifiedName(node, ts.createIdentifier(newName), node.right);
            }
            node = ts.visitEachChild(node, Visit, context);
            return node;
        }
        return ts.visitNode(node, Visit);
    }; };
    var result = ts.transform(node, [t]);
    return result.transformed[0];
}
function findNode(node) {
    var reslut = [];
    var visit = function (level) { return function Visit(node) {
        console.info("│           ".repeat(level) + "├──┌── ", ts.SyntaxKind[node.kind]);
        console.info("│           ".repeat(level) + "│  └── ", node);
        // console.info("│      ".repeat(level) + "│")
        ts.forEachChild(node, visit(level + 1));
    }; };
    visit(0)(node);
    return reslut;
}
exports.findNode = findNode;
