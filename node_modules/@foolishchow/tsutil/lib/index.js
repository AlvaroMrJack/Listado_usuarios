"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = __importStar(require("typescript"));
var os_1 = require("os");
var tsquery_1 = require("./tsquery");
exports.$ = tsquery_1.$;
var tsquery_2 = require("@phenomnomnominal/tsquery");
exports.tsquery = tsquery_2.tsquery;
exports.createImportSpecifier = function (option) { return ts.createImportSpecifier(option.propertyName, option.name); };
exports.createImportClause = function (option) { return ts.createImportClause(option.name, option.namedBindings); };
exports.createImportDeclaration = function (option) { return ts.createImportDeclaration(option.decorators, option.modifiers, option.importClause, option.moduleSpecifier); };
exports.createArrowFunction = function (option) { return ts.createArrowFunction(option.modifiers, option.typeParameters, option.parameters, option.type, option.equalsGreaterThanToken, option.body); };
exports.createTypeReferenceNode = function (typeName, typeArguments) { return ts.createTypeReferenceNode(typeName, typeArguments); };
exports.createVariableDeclaration = function (option) { return ts.createVariableDeclaration(option.name, option.type, option.initializer); };
exports.createVariableStatement = function (option) { return ts.createVariableStatement(option.modifiers, option.declarationList); };
exports.createParameter = function (option) { return ts.createParameter(option.decorators, option.modifiers, option.dotDotDotToken, option.name, option.questionToken, option.type, option.initializer); };
exports.createMethod = function (options) { return ts.createMethod(options.decorators, options.modifiers, options.asteriskToken, options.name, options.questionToken, options.typeParameters, options.parameters, options.type, options.body); };
exports.createInterface = function (options) { return ts.createInterfaceDeclaration(options.decorators, options.modifiers, options.name, options.typeParameters, options.heritageClauses, options.members); };
exports.createModule = function (option) { return ts.createModuleDeclaration(option.decorators, option.modifiers, option.name, option.body, option.flags); };
exports.createProperty = function (option) { return ts.createProperty(option.decorators, option.modifiers, option.name, option.questionOrExclamationToken, option.type, option.initializer); };
exports.createPropertySignature = function (options) { return ts.createPropertySignature(options.modifiers, options.name, options.questionToken, options.type, options.initializer); };
exports.createCallSignature = function (options) { return ts.createCallSignature(options.typeParameters, options.parameters, options.type); };
exports.createFunctionDeclaration = function (option) { return ts.createFunctionDeclaration(option.decorators, option.modifiers, option.asteriskToken, option.name, option.typeParameters, option.parameters, option.type, option.body); };
/**
 * ```
 *  modifiers(export)  decorators(@N)  type name<typeParameters> = type
 *   export          @N       type  name<T> =  {}
 *```
 */
exports.createTypeAliasDeclaration = function (option) { return ts.createTypeAliasDeclaration(option.decorators, option.modifiers, option.name, option.typeParameters, option.type); };
exports.addComment = function (node, comment, isFull) {
    if (isFull === void 0) { isFull = false; }
    if (comment) {
        var c = isFull ? comment.replace(/^(\/\*)|(\*\/)$/g, "") : "*" + os_1.EOL + " * " + comment.split(os_1.EOL).join(os_1.EOL + " * ") + (os_1.EOL + " ");
        ts.addSyntheticLeadingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, c, true);
    }
    return node;
};
exports.addComments = function (node, comment, isFull) {
    if (isFull === void 0) { isFull = false; }
    comment.forEach(function (c) { return exports.addComment(node, c, isFull); });
};
exports.parseComment = function (node) {
    var range = ts.getCommentRange(node);
    if (range.jsDoc) {
        return range.jsDoc.map(function (n) {
            var s = n.getFullText().replace(/^(\/\*)|(\*\/)$/g, "");
            return s
                .split(os_1.EOL)
                .map(function (s) { return s.replace(/^\s{1,}|\s$/g, '').replace(/^\*/g, '').replace(/^\s/, ''); })
                .filter(function (i) { return i != '' && i != "*"; })
                .join(os_1.EOL);
        });
    }
    return [];
};
